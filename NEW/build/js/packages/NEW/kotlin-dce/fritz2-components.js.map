{"version":3,"file":"fritz2-components.js","sources":["collections/Maps.kt","collections/Collections.kt","../../../../../components/src/jsMain/kotlin/dev/fritz2/components/box.kt","../../../../../styling/src/jsMain/kotlin/dev.fritz2.styling/params/params.kt","../../../../../components/src/jsMain/kotlin/dev/fritz2/components/button.kt","util/Standard.kt","../../../../../components/src/jsMain/kotlin/dev/fritz2/components/checkbox.kt","../../../../../components/src/jsMain/kotlin/dev/fritz2/components/icons.kt","../../../../../components/src/jsMain/kotlin/dev/fritz2/components/input.kt","../../../../../components/src/jsMain/kotlin/dev/fritz2/components/spinner.kt","../../../../../components/src/jsMain/kotlin/dev/fritz2/components/stack.kt"],"sourcesContent":["/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\nprivate object EmptyMap : Map<Any?, Nothing>, Serializable {\n    private const val serialVersionUID: Long = 8246714829545688274\n\n    override fun equals(other: Any?): Boolean = other is Map<*, *> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"{}\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n\n    override fun containsKey(key: Any?): Boolean = false\n    override fun containsValue(value: Nothing): Boolean = false\n    override fun get(key: Any?): Nothing? = null\n    override val entries: Set<Map.Entry<Any?, Nothing>> get() = EmptySet\n    override val keys: Set<Any?> get() = EmptySet\n    override val values: Collection<Nothing> get() = EmptyList\n\n    private fun readResolve(): Any = EmptyMap\n}\n\n/**\n * Returns an empty read-only map of specified type.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\npublic fun <K, V> emptyMap(): Map<K, V> = @Suppress(\"UNCHECKED_CAST\") (EmptyMap as Map<K, V>)\n\n/**\n * Returns a new read-only map with the specified contents, given as a list of pairs\n * where the first value is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =\n    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\n\n/**\n * Returns an empty read-only map.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mapOf(): Map<K, V> = emptyMap()\n\n/**\n * Returns an empty new [MutableMap].\n *\n * The returned map preserves the entry iteration order.\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mutableMapOf(): MutableMap<K, V> = LinkedHashMap()\n\n/**\n * Returns a new [MutableMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.mutableMapFromPairs\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\npublic fun <K, V> mutableMapOf(vararg pairs: Pair<K, V>): MutableMap<K, V> =\n    LinkedHashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [HashMap].\n *\n * @sample samples.collections.Maps.Instantiation.emptyHashMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> hashMapOf(): HashMap<K, V> = HashMap<K, V>()\n\n/**\n * Returns a new [HashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * @sample samples.collections.Maps.Instantiation.hashMapFromPairs\n */\npublic fun <K, V> hashMapOf(vararg pairs: Pair<K, V>): HashMap<K, V> = HashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [LinkedHashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> linkedMapOf(): LinkedHashMap<K, V> = LinkedHashMap<K, V>()\n\n/**\n * Returns a new [LinkedHashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.linkedMapFromPairs\n */\npublic fun <K, V> linkedMapOf(vararg pairs: Pair<K, V>): LinkedHashMap<K, V> = pairs.toMap(LinkedHashMap(mapCapacity(pairs.size)))\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> buildMap(@BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildMapInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <K, V> buildMapInternal(builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of pairs added in the [builderAction].\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> buildMap(capacity: Int, @BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildMapInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <K, V> buildMapInternal(capacity: Int, builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>\n\n/**\n * Calculate the initial capacity of a map.\n */\n@PublishedApi\ninternal expect fun mapCapacity(expectedSize: Int): Int\n\n/**\n * Returns `true` if this map is not empty.\n * @sample samples.collections.Maps.Usage.mapIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable map is either null or empty.\n * @sample samples.collections.Maps.Usage.mapIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || isEmpty()\n}\n\n/**\n * Returns the [Map] if its not `null`, or the empty [Map] otherwise.\n *\n * @sample samples.collections.Maps.Usage.mapOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>?.orEmpty(): Map<K, V> = this ?: emptyMap()\n\n/**\n * Returns this map if it's not empty\n * or the result of calling [defaultValue] function if the map is empty.\n *\n * @sample samples.collections.Maps.Usage.mapIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <M, R> M.ifEmpty(defaultValue: () -> R): R where M : Map<*, *>, M : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Checks if the map contains the given key.\n *\n * This method allows to use the `x in map` syntax for checking whether an object is contained in the map.\n *\n * @sample samples.collections.Maps.Usage.containsKey\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.contains(key: K): Boolean = containsKey(key)\n\n/**\n * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.get(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, V>).get(key)\n\n/**\n * Allows to use the index operator for storing values in a mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.set(key: K, value: V): Unit {\n    put(key, value)\n}\n\n/**\n * Returns `true` if the map contains the specified [key].\n *\n * Allows to overcome type-safety restriction of `containsKey` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K> Map<out K, *>.containsKey(key: K): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, *>).containsKey(key)\n\n/**\n * Returns `true` if the map maps one or more keys to the specified [value].\n *\n * Allows to overcome type-safety restriction of `containsValue` that requires to pass a value of type `V`.\n *\n * @sample samples.collections.Maps.Usage.containsValue\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <K, @kotlin.internal.OnlyInputTypes V> Map<K, V>.containsValue(value: V): Boolean = this.containsValue(value)\n\n\n/**\n * Removes the specified key and its corresponding value from this map.\n *\n * @return the previous value associated with the key, or `null` if the key was not present in the map.\n\n * Allows to overcome type-safety restriction of `remove` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K, V> MutableMap<out K, V>.remove(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableMap<K, V>).remove(key)\n\n/**\n * Returns the key component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component1(): K = key\n\n/**\n * Returns the value component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component2(): V = value\n\n/**\n * Converts entry to [Pair] with key being first component and value being second.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map.Entry<K, V>.toPair(): Pair<K, V> = Pair(key, value)\n\n/**\n * Returns the value for the given key, or the result of the [defaultValue] function if there was no entry for the given key.\n *\n * @sample samples.collections.Maps.Usage.getOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>.getOrElse(key: K, defaultValue: () -> V): V = get(key) ?: defaultValue()\n\n\ninternal inline fun <K, V> Map<K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    if (value == null && !containsKey(key)) {\n        return defaultValue()\n    } else {\n        @Suppress(\"UNCHECKED_CAST\")\n        return value as V\n    }\n}\n\n/**\n * Returns the value for the given [key] or throws an exception if there is no such key in the map.\n *\n * If the map was created by [withDefault], resorts to its `defaultValue` provider function\n * instead of throwing an exception.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and\n * no implicit default value was provided for that map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<K, V>.getValue(key: K): V = getOrImplicitDefault(key)\n\n/**\n * Returns the value for the given key. If the key is not found in the map, calls the [defaultValue] function,\n * puts its result into the map under the given key and returns it.\n *\n * Note that the operation is not guaranteed to be atomic if the map is being modified concurrently.\n *\n * @sample samples.collections.Maps.Usage.getOrPut\n */\npublic inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n\n/**\n * Returns an [Iterator] over the entries in the [Map].\n *\n * @sample samples.collections.Maps.Usage.forOverEntries\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>> = entries.iterator()\n\n/**\n * Returns a [MutableIterator] over the mutable entries in the [MutableMap].\n *\n */\n@kotlin.jvm.JvmName(\"mutableIterator\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> = entries.iterator()\n\n/**\n * Populates the given [destination] map with entries having the keys of this map and the values obtained\n * by applying the [transform] function to each entry in this [Map].\n */\npublic inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, { it.key }, transform)\n}\n\n/**\n * Populates the given [destination] map with entries having the keys obtained\n * by applying the [transform] function to each entry in this [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n */\npublic inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, transform, { it.value })\n}\n\n/**\n * Puts all the given [pairs] into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given collection into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given sequence into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Returns a new map with entries having the keys of this map and the values obtained by applying the [transform]\n * function to each entry in this [Map].\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapValues\n */\npublic inline fun <K, V, R> Map<out K, V>.mapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> {\n    return mapValuesTo(LinkedHashMap<K, R>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a new Map with entries having the keys obtained by applying the [transform] function to each entry in this\n * [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapKeys\n */\npublic inline fun <K, V, R> Map<out K, V>.mapKeys(transform: (Map.Entry<K, V>) -> R): Map<R, V> {\n    return mapKeysTo(LinkedHashMap<R, V>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a map containing all key-value pairs with keys matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterKeys\n */\npublic inline fun <K, V> Map<out K, V>.filterKeys(predicate: (K) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.key)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n/**\n * Returns a map containing all key-value pairs with values matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n *  @sample samples.collections.Maps.Filtering.filterValues\n */\npublic inline fun <K, V> Map<out K, V>.filterValues(predicate: (V) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.value)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n\n/**\n * Appends all entries matching the given [predicate] into the mutable map given as [destination] parameter.\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filter\n */\npublic inline fun <K, V> Map<out K, V>.filter(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Appends all entries not matching the given [predicate] into the given [destination].\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterNotTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (!predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs not matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterNot\n */\npublic inline fun <K, V> Map<out K, V>.filterNot(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterNotTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Returns a new map containing all key-value pairs from the given collection of pairs.\n *\n * The returned map preserves the entry iteration order of the original collection.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyMap()\n            1 -> mapOf(if (this is List) this[0] else iterator().next())\n            else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n        }\n    }\n    return toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given collection of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given array of pairs.\n *\n * The returned map preserves the entry iteration order of the original array.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> mapOf(this[0])\n    else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n}\n\n/**\n *  Populates and returns the [destination] mutable map with key-value pairs from the given array of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given sequence of pairs.\n *\n * The returned map preserves the entry iteration order of the original sequence.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Sequence<Pair<K, V>>.toMap(): Map<K, V> = toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given sequence of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new read-only map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMap()\n    else -> toMutableMap()\n}\n\n/**\n * Returns a new mutable map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> = LinkedHashMap(this)\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Creates a new read-only map by replacing or adding an entry to this map from a given key-value [pair].\n *\n * The returned map preserves the entry iteration order of the original map.\n * The [pair] is iterated in the end if it has a unique key.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pair: Pair<K, V>): Map<K, V> =\n    if (this.isEmpty()) mapOf(pair) else LinkedHashMap(this).apply { put(pair.first, pair.second) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given collection of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] collection.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Iterable<Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given array of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] array.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Array<out Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given sequence of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] sequence.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Sequence<Pair<K, V>>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(pairs) }.optimizeReadOnlyMap()\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from another [map].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those entries of another [map] that are missing in this map are iterated in the end in the order of that [map].\n */\npublic operator fun <K, V> Map<out K, V>.plus(map: Map<out K, V>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(map) }\n\n\n/**\n * Appends or replaces the given [pair] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pair: Pair<K, V>) {\n    put(pair.first, pair.second)\n}\n\n/**\n * Appends or replaces all pairs from the given collection of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Iterable<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given array of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Array<out Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given sequence of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Sequence<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all entries from the given [map] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(map: Map<K, V>) {\n    putAll(map)\n}\n\n/**\n * Returns a map containing all entries of the original map except the entry with the given [key].\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(key: K): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(key) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] collection.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Iterable<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] array.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Array<out K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] sequence.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Sequence<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Removes the entry with the given [key] from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(key: K) {\n    remove(key)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] collection from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] array from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries from the keys of which are contained in the given [keys] sequence from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>) {\n    this.keys.removeAll(keys)\n}\n\n\n// do not expose for now @PublishedApi\ninternal fun <K, V> Map<K, V>.optimizeReadOnlyMap() = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMapOrSelf()\n    else -> this\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\nimport kotlin.random.Random\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(@BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(capacity: Int, @BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\n\n/**\n * Returns a new list with the elements of this list randomly shuffled\n * using the specified [random] instance as the source of randomness.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Iterable<T>.shuffled(random: Random): List<T> = toMutableList().apply { shuffle(random) }\n\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which the given [comparison] function returns zero using the binary search algorithm.\n *\n * The list is expected to be sorted so that the signs of the [comparison] function's return values ascend on the list elements,\n * i.e. negative values come before zero and zeroes come before positive values.\n * Otherwise, the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that returns zero when called on the list element being searched.\n * On the elements coming before the target element, the function must return negative values;\n * on the elements coming after the target element, the function must return positive values.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n",null,null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n",null,null,null,null,null],"names":[],"mappings":"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"}